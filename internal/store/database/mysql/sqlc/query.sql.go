// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlc

import (
	"context"
)

const getDeposites = `-- name: GetDeposites :many
SELECT id, blocknumber, blocktimestamp, fee, hash, pubkey FROM Deposit ORDER BY blockTimestamp DESC LIMIT ? OFFSET ?
`

type GetDepositesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetDeposites(ctx context.Context, arg GetDepositesParams) ([]Deposit, error) {
	rows, err := q.db.QueryContext(ctx, getDeposites, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Deposit
	for rows.Next() {
		var i Deposit
		if err := rows.Scan(
			&i.ID,
			&i.Blocknumber,
			&i.Blocktimestamp,
			&i.Fee,
			&i.Hash,
			&i.Pubkey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDeposit = `-- name: InsertDeposit :exec
INSERT INTO Deposit (blockNumber, blockTimestamp, fee, hash, pubkey) VALUES (?, ?, ?, ?, ?)
`

type InsertDepositParams struct {
	Blocknumber    int32
	Blocktimestamp int32
	Fee            int32
	Hash           string
	Pubkey         string
}

func (q *Queries) InsertDeposit(ctx context.Context, arg InsertDepositParams) error {
	_, err := q.db.ExecContext(ctx, insertDeposit,
		arg.Blocknumber,
		arg.Blocktimestamp,
		arg.Fee,
		arg.Hash,
		arg.Pubkey,
	)
	return err
}
